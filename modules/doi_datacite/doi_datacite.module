<?php

/**
 * @file
 * Contains the doi_datacite.module.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\node\Entity\Node;
use Drupal\Core\Link;
use Drupal\Core\Url;

/**
 * Implements hook_form_alter().
 */
function doi_datacite_form_alter(&$form, FormStateInterface &$form_state, $form_id) {
  // Inject fields required by this minter into the Persistent Identifier admin form.
  if ($form_id == 'persistent_identifiers_admin_settings') {
    $config = \Drupal::config('doi_datacite.settings');
    $form['doi_datacite_api_endpoint'] = [
      '#type' => 'select',
      '#options' => [
        'https://api.test.datacite.org/dois' => 'https://api.test.datacite.org/dois',
        'https://api.datacite.org/dois' => 'https://api.datacite.org/dois',
      ],
      '#title' => t('DataCite API endpoint'),
      '#default_value' => $config->get('doi_datacite_api_endpoint'),
      '#description' => t("The DataCite API endpoint URL. Either "),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $test_fabrica_link = Link::fromTextAndUrl('DataCite Fabrica Test', Url::fromUri('https://doi.test.datacite.org'));
    $fabrica_link = Link::fromTextAndUrl('DataCite Fabrica', Url::fromUri('https://doi.datacite.org'));
    $form['doi_datacite_prefix'] = [
      '#type' => 'textfield',
      '#title' => t('DOI prefix'),
      '#default_value' => $config->get('doi_datacite_prefix'),
      '#description' => t("DOI prefix. Note: You will need to assign separate test and production prefixes at @fabrica_test_link and @fabrica_link.", ['@fabrica_test_link' => $test_fabrica_link->toString(), '@fabrica_link' => $fabrica_link->toString()]),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $form['doi_datacite_suffix_source'] = [
      '#type' => 'radios',
      '#title' => t('Source of DOI suffix'),
      '#options' => ['uuid' => 'Node UUID', 'auto' => 'Autogenerated by DataCite', 'id' => 'Node ID'],
      '#default_value' => $config->get('doi_datacite_suffix_source'),
      '#description' => t("UUIDs are longer but are guaranteed to be unique; node IDs have a greater chance of not being unique within a DOI prefix."),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $form['doi_datacite_username'] = [
      '#type' => 'textfield',
      '#title' => t('DataCite repository ID'),
      '#default_value' => $config->get('doi_datacite_username'),
      '#description' => t("Your DataCite API repository ID."),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $form['doi_datacite_password'] = [
      '#type' => 'textfield',
      '#title' => 'DataCite API password',
      '#default_value' => $config->get('doi_datacite_password'),
      '#description' => t("Your DataCite API password."),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $form['doi_datacite_field_mappings'] = [
      '#type' => 'textarea',
      '#title' => t('Node to DataCite field mappings'),
      '#default_value' => $config->get('doi_datacite_field_mappings'),
      '#description' => t('Mappings from node fields to DataCite metadata elements. Separate using colon (:), one mapping per line.'),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];

    $form['#submit'][] = 'doi_datacite_admin_settings_submit';
  }
}

/**
 * Implements hook_form_node_form_alter().
 */
function doi_datacite_form_node_form_alter(&$form, FormStateInterface $form_state) {
  // Inject fields required by this minter into the node edit form.
  $config = \Drupal::config('persistent_identifiers.settings');
  $entity = $form_state->getFormObject()->getEntity();
  $content_type = $entity->bundle();
  $allowed_types = $config->get('persistent_identifiers_bundles');

  if (!in_array($content_type, $allowed_types, TRUE)) {
    return;
  }

  if (\Drupal::currentUser()->hasPermission('mint persistent identifiers')) {
    $minter_id = Drupal::config('persistent_identifiers.settings')->get('persistent_identifiers_minter');
    if ($minter_id == 'doi_datacite.minter.datacitedois') {
      $minter_service = \Drupal::service('doi_datacite.minter.datacitedois');
      $datacite_metadata_values = $minter_service->getDataCiteElementValues($entity->id());
      devel_debug($datacite_metadata_values, 'From form');
      // DataCite requires the use of this following controlled list of resource types.
      $resource_type_values = $minter_service->getResourceTypes();
      // Only show this form element if the user checks the "Mint DataCite DOI" box.
      $form['doi_datacite_required_fields'] = [
        '#type' => 'fieldset',
        '#title' => t('DataCite-specific metadata'),
        '#weight' => 100,
        '#states' => [
          'visible' => [
            ':input[id="persistent_identifiers_mint_and_persist"]' => ['checked' => TRUE],
          ],
        ],
       ];
      $form['doi_datacite_required_fields']['required_note'] = [
        '#markup' => t('Note: All of these fields are required by DataCite to mint a DOI. They do not duplicate existing metadata.'),
      ];     
      $form['doi_datacite_required_fields']['doi_datacite_resource_type'] = [
        '#type' => 'radios',
        '#options' => $resource_type_values,
        '#title' => t("DataCite resource types"),
        '#description' => t("Metadata submitted to DataCite requires one of these " .
	"resource types."),
      ];
      $form['doi_datacite_required_fields']['doi_datacite_creator'] = [
        '#type' => 'textfield',
        '#title' => t('Creator'),
        '#description' => t("Separate repeated values with semicolons."),
      ];
      $form['doi_datacite_required_fields']['doi_datacite_publication_year'] = [
        '#title' => t('Publication year'),
        '#type' => 'textfield',
        '#default_value' => $datacite_metadata_values['publicationYear'],
        '#description' => t("Must be in YYYY format."),
      ];
      $form['doi_datacite_required_fields']['doi_datacite_publisher'] = [
        '#title' => t('Publisher'),
        '#type' => 'textfield',
      ];

      $form['#validate'][] = 'doi_datacite_check_for_required_datacite_elements';
    }
  }
}

/**
 * Submit callback.
 *
 * Saves the value of the minter-specific admin options configured
 * in the implementation of hook_form_alter() for
 * persistent_identifiers_admin_settings' `above.
 *
 * @param array $form
 *   The form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function doi_datacite_admin_settings_submit(array &$form, FormStateInterface $form_state) {
  $minter = Drupal::config('persistent_identifiers.settings')->get('persistent_identifiers_minter');
  if ($minter == 'doi_datacite.minter.datacitedois') {
    $endpoint = trim($form_state->getValue('doi_datacite_api_endpoint'));
    $prefix = trim($form_state->getValue('doi_datacite_prefix'));
    $prefix = rtrim($prefix, '/');
    $suffix_source = $form_state->getValue('doi_datacite_suffix_source');
    $username = trim($form_state->getValue('doi_datacite_username'));
    $password = trim($form_state->getValue('doi_datacite_password'));
    $doi_datacite_field_mappings = trim($form_state->getValue('doi_datacite_field_mappings'));
    $config_factory = \Drupal::configFactory();
    $config_factory->getEditable('doi_datacite.settings')
      ->set('doi_datacite_api_endpoint', $endpoint)
      ->set('doi_datacite_prefix', $prefix)
      ->set('doi_datacite_suffix_source', $suffix_source)
      ->set('doi_datacite_username', $username)
      ->set('doi_datacite_password', $password)
      ->set('doi_datacite_field_mappings', $doi_datacite_field_mappings)
      ->save();
  }
}

/**
 * Form validation callback.
 *
 * Checks to see if the elements required by DataCite are populated.
 *
 * @param array $form
 *   The form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function doi_datacite_check_for_required_datacite_elements(array $form, FormStateInterface &$form_state) {
  if (\Drupal::currentUser()->hasPermission('mint persistent identifiers')) {
    // We only want to validate these elements if the "Mint DataCite DOI" checkbox is checked.
    if ($form_state->getValue('mint_and_persist') == 1) {
      $minter_id = Drupal::config('persistent_identifiers.settings')->get('persistent_identifiers_minter');
      if ($minter_id == 'doi_datacite.minter.datacitedois') {
	// DataCite resource type.
        if (empty($form_state->getValue('doi_datacite_resource_type'))) {
          $form_state->setErrorByName('doi_datacite_resource_type', t('You must choose a DataCite resource type.'));
	}
	// DataCite creator.
        if (empty($form_state->getValue('doi_datacite_creator'))) {
          $form_state->setErrorByName('doi_datacite_creator', t('You must enter a value in the DataCite Creator field.'));
	}
	// DataCite publication year.
        if (empty($form_state->getValue('doi_datacite_publication_year'))) {
	  $form_state->setErrorByName('doi_datacite_publication_year', t('You must enter a value in the DataCite ' .
          'Publication year field, in YYYY format.'));
	}
	if (!preg_match('/^\d\d\d\d$/', $form_state->getValue('doi_datacite_publication_year'))) {
	  $form_state->setErrorByName('doi_datacite_publication_year', t('The date must be in YYYY format'));
        }
	// DataCite publisher.
        if (empty($form_state->getValue('doi_datacite_publisher'))) {
          $form_state->setErrorByName('doi_datacite_publisher', t('You must enter a value in the DataCite Publisher field.'));
	}
      }
    }
  }
}
