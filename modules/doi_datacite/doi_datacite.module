<?php

/**
 * @file
 * Contains the doi_datacite.module.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\node\Entity\Node;
use Drupal\Core\Link;
use Drupal\Core\Url;

/**
 * Implements hook_form_alter().
 */
function doi_datacite_form_alter(&$form, FormStateInterface &$form_state, $form_id) {
  // Inject fields required by this minter into the Persistent Identifier admin form.
  if ($form_id == 'persistent_identifiers_admin_settings') {
    $form['doi_begin_label'] = array(
      '#type' => 'markup',
      '#markup' => '<label><b>DOI</b></label><hr>',
    );

    $pid_config = \Drupal::config('persistent_identifiers.settings');
    $config = \Drupal::config('doi_datacite.settings');

    $form['doi_datacite_api_endpoint'] = [
      '#type' => 'select',
      '#options' => [
        'https://api.test.datacite.org/dois' => 'https://api.test.datacite.org/dois',
        'https://api.datacite.org/dois' => 'https://api.datacite.org/dois',
      ],
      '#title' => t('DataCite API endpoint'),
      '#default_value' => $config->get('doi_datacite_api_endpoint'),
      '#description' => t("The DataCite API endpoint URL. Either "),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $test_fabrica_link = Link::fromTextAndUrl('DataCite Fabrica Test', Url::fromUri('https://doi.test.datacite.org'));
    $fabrica_link = Link::fromTextAndUrl('DataCite Fabrica', Url::fromUri('https://doi.datacite.org'));
    $form['doi_datacite_prefix'] = [
      '#type' => 'textfield',
      '#title' => t('DOI prefix'),
      '#default_value' => $config->get('doi_datacite_prefix'),
      '#description' => t("DOI prefix. Note: You will need to assign separate test and production prefixes at @fabrica_test_link and @fabrica_link.", ['@fabrica_test_link' => $test_fabrica_link->toString(), '@fabrica_link' => $fabrica_link->toString()]),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $form['doi_datacite_suffix_source'] = [
      '#type' => 'radios',
      '#title' => t('Source of DOI suffix'),
      '#options' => ['uuid' => 'Node UUID', 'auto' => 'Autogenerated by DataCite', 'id' => 'Node ID'],
      '#default_value' => $config->get('doi_datacite_suffix_source'),
      '#description' => t("UUIDs are longer but are guaranteed to be unique; node IDs have a greater chance of not being unique within a DOI prefix."),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $form['doi_datacite_username'] = [
      '#type' => 'textfield',
      '#title' => t('DataCite repository ID'),
      '#default_value' => $config->get('doi_datacite_username'),
      '#description' => t("Your DataCite API repository ID."),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $form['doi_datacite_password'] = [
      '#type' => 'password',
      '#title' => 'DataCite API password',
      '#default_value' => $config->get('doi_datacite_password'),
      '#description' => t("Your DataCite API password."),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];

    $bundle_info = \Drupal::service('entity_type.bundle.info')->getBundleInfo('node');
    $bundles = [];
    foreach ($bundle_info as $id => $details) {
      $bundles[$id] = $details['label'];
    }

    $selected_bundles = $pid_config->get('persistent_identifiers_bundles');
    foreach ($selected_bundles as &$bundle_id) {
      if ($bundle_id != '0') {
        $bundle_id_raw = $bundle_id;
        $bundle_id = '_' . $bundle_id;
        $form['doi_datacite_field_mappings' . $bundle_id] = [
          '#type' => 'fieldset',
          '#collapsed' => TRUE,
          '#title' => t('DataCite field mappings for ' . $bundles[$bundle_id_raw]),
          '#description' => t('Mappings from fields in the "'  . $bundles[$bundle_id_raw] . '" content type to DataCite metadata elements.'),
          '#states' => [
            'visible' => [
              ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
            ],
          ],
        ];
        $form['doi_datacite_field_mappings' . $bundle_id]['doi_datacite_creators_mapping' . $bundle_id] = [
          '#type' => 'textfield',
          '#title' => t('DataCite creators'),
          '#default_value' => $config->get('doi_datacite_creators_mapping' . $bundle_id),
          '#states' => [
            'visible' => [
              ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
            ],
          ],
        ];
        $form['doi_datacite_field_mappings' . $bundle_id]['doi_datacite_publisher_mapping' . $bundle_id] = [
          '#type' => 'textfield',
          '#title' => t('DataCite publisher'),
          '#default_value' => $config->get('doi_datacite_publisher_mapping' . $bundle_id),
          '#states' => [
            'visible' => [
              ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
            ],
          ],
        ];
        $form['doi_datacite_field_mappings' . $bundle_id]['doi_datacite_publicationyear_mapping' . $bundle_id] = [
          '#type' => 'textfield',
          '#title' => t('DataCite publicationYear'),
          '#default_value' => $config->get('doi_datacite_publicationyear_mapping' . $bundle_id),
          '#states' => [
            'visible' => [
              ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
            ],
          ],
        ];
      }
    }

    $form['doi_end_label'] = array(
      '#type' => 'markup',
      '#markup' => '<br><br>',
    );
    $form['#submit'][] = 'doi_datacite_admin_settings_submit';
  }
}

/**
 * Implements hook_form_node_form_alter().
 */
function doi_datacite_form_node_form_alter(&$form, FormStateInterface $form_state) {
  // Inject fields required by this minter into the node edit form.
  $config = \Drupal::config('persistent_identifiers.settings');
  $entity = $form_state->getFormObject()->getEntity();
  $content_type = $entity->bundle();
  $allowed_types = $config->get('persistent_identifiers_bundles');

  if (!in_array($content_type, $allowed_types, TRUE)) {
    return;
  }

  if (\Drupal::currentUser()->hasPermission('mint persistent identifiers')) {
    $minter_id = Drupal::config('persistent_identifiers.settings')->get('persistent_identifiers_minter');
    if ($minter_id == 'doi_datacite.minter.datacitedois') {
      $minter_service = \Drupal::service('doi_datacite.minter.datacitedois');
      $datacite_metadata_values = $minter_service->getDataCiteElementValues($entity->id());
      // DataCite requires the use of this following controlled list of resource types.
      $resource_type_values = $minter_service->getResourceTypes();
      // Only show this form element if the user checks the "Mint DataCite DOI" box.
      $form['doi_datacite_required_fields'] = [
        '#type' => 'fieldset',
        '#title' => t('DataCite-specific metadata'),
        '#weight' => 100,
        '#states' => [
          'visible' => [
            ':input[id="persistent_identifiers_mint_and_persist"]' => ['checked' => TRUE],
          ],
        ],
       ];
      $form['doi_datacite_required_fields']['required_note'] = [
        '#markup' => t('Note: All of these fields are required by DataCite to mint a DOI. They do not duplicate existing metadata.'),
      ];
      $form['doi_datacite_required_fields']['doi_datacite_resource_type'] = [
        '#type' => 'radios',
        '#options' => $resource_type_values,
        '#title' => t("DataCite resource type"),
        '#label_attributes' => ['class' =>'form-required'],
      ];
      $form['doi_datacite_required_fields']['doi_datacite_creator'] = [
        '#type' => 'textfield',
        '#title' => t('Creator'),
        '#description' => t("Separate repeated values with semicolons."),
        '#default_value' => $datacite_metadata_values['creators'],
	'#label_attributes' => ['class' =>'form-required'],
	'#placeholder' => 'Sorry, could not prefill creators...'
      ];
      $form['doi_datacite_required_fields']['doi_datacite_publication_year'] = [
        '#title' => t('Publication year'),
        '#type' => 'textfield',
        '#default_value' => $datacite_metadata_values['publicationYear'],
        '#description' => t("Must be in YYYY format."),
        '#label_attributes' => ['class' =>'form-required'],
	'#placeholder' => 'Sorry, could not prefill publication year...'
      ];
      $form['doi_datacite_required_fields']['doi_datacite_publisher'] = [
        '#title' => t('Publisher'),
        '#type' => 'textfield',
        '#default_value' => $datacite_metadata_values['publisher'],
        '#label_attributes' => ['class' =>'form-required'],
	'#placeholder' => 'Sorry, could not prefill publisher...'
      ];

      $form['#validate'][] = 'doi_datacite_check_for_required_datacite_elements';
    }
  }
}

/**
 * Submit callback.
 *
 * Saves the value of the minter-specific admin options configured
 * in the implementation of hook_form_alter() for
 * persistent_identifiers_admin_settings' `above.
 *
 * @param array $form
 *   The form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function doi_datacite_admin_settings_submit(array &$form, FormStateInterface $form_state) {
  $minter = Drupal::config('persistent_identifiers.settings')->get('persistent_identifiers_minter');
  if ($minter == 'doi_datacite.minter.datacitedois') {
    $prefix = trim($form_state->getValue('doi_datacite_prefix'));
    $prefix = rtrim($prefix, '/');
    $config_factory = \Drupal::configFactory();
    $config_factory->getEditable('doi_datacite.settings')
      ->set('doi_datacite_api_endpoint', trim($form_state->getValue('doi_datacite_api_endpoint')))
      ->set('doi_datacite_prefix', $prefix)
      ->set('doi_datacite_suffix_source', $form_state->getValue('doi_datacite_suffix_source'))
      ->set('doi_datacite_username', trim($form_state->getValue('doi_datacite_username')))
      ->set('doi_datacite_password', trim($form_state->getValue('doi_datacite_password')))
      ->save();

    $pid_config = \Drupal::config('persistent_identifiers.settings');
    $selected_bundles = $pid_config->get('persistent_identifiers_bundles');
    foreach ($selected_bundles as &$bundle_id) {
      if ($bundle_id != '0') {
        $bundle_id = '_' . $bundle_id;
        $config_factory->getEditable('doi_datacite.settings')
          ->set('doi_datacite_creators_mapping' . $bundle_id, trim($form_state->getValue('doi_datacite_creators_mapping' . $bundle_id)))
          ->set('doi_datacite_publisher_mapping' . $bundle_id, trim($form_state->getValue('doi_datacite_publisher_mapping' . $bundle_id)))
          ->set('doi_datacite_publicationyear_mapping' . $bundle_id, trim($form_state->getValue('doi_datacite_publicationyear_mapping' . $bundle_id)))
          ->save();
      }
    }
  }
}

/**
 * Form validation callback.
 *
 * Checks to see if the elements required by DataCite are populated.
 *
 * @param array $form
 *   The form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function doi_datacite_check_for_required_datacite_elements(array $form, FormStateInterface &$form_state) {
  if (\Drupal::currentUser()->hasPermission('mint persistent identifiers')) {
    // We only want to validate these elements if the "Mint DataCite DOI" checkbox is checked.
    if ($form_state->getValue('mint_and_persist') == 1) {
      $minter_id = Drupal::config('persistent_identifiers.settings')->get('persistent_identifiers_minter');
      if ($minter_id == 'doi_datacite.minter.datacitedois') {
	// DataCite resource type.
        if (empty($form_state->getValue('doi_datacite_resource_type'))) {
          $form_state->setErrorByName('doi_datacite_resource_type', t('You must choose a DataCite resource type.'));
	}
	// DataCite creator.
        if (empty($form_state->getValue('doi_datacite_creator'))) {
          $form_state->setErrorByName('doi_datacite_creator', t('You must enter a value in the DataCite Creator field.'));
	}
	// DataCite publication year.
        if (empty($form_state->getValue('doi_datacite_publication_year'))) {
	  $form_state->setErrorByName('doi_datacite_publication_year', t('You must enter a value in the DataCite ' .
          'Publication year field, in YYYY format.'));
	}
	if (!preg_match('/^\d\d\d\d$/', $form_state->getValue('doi_datacite_publication_year'))) {
	  $form_state->setErrorByName('doi_datacite_publication_year', t('The date must be in YYYY format'));
        }
	// DataCite publisher.
        if (empty($form_state->getValue('doi_datacite_publisher'))) {
          $form_state->setErrorByName('doi_datacite_publisher', t('You must enter a value in the DataCite Publisher field.'));
	}

	// If the target field already has a DOI, tell the user.
        $config = \Drupal::config('doi_datacite.settings');
	$doi_prefix = $config->get('doi_datacite_prefix');
        $pid_config = \Drupal::config('persistent_identifiers.settings');
        $node = $form_state->getFormObject()->getEntity();
	$doi_field_name = $pid_config->get('persistent_identifiers_target_field');
        if ($node->hasField($doi_field_name)) {
          $doi_field_values = $node->get($doi_field_name)->getValue();
          if (array_key_exists('value', $doi_field_values[0])) {
            if (preg_match('/' . $doi_prefix . '\//', $doi_field_values[0]['value'])) {
              $form_state->setErrorByName($doi_field_name, t('This node already has a DOI.'));
            }
          }
	}

      }
    }
  }
}
